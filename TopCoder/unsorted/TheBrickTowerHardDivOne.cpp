#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <iterator>
#include <functional>
#include <bitset>
#include <ctime>
#define pb push_back
#define mp make_pair      
using namespace std;
 
typedef long long ll;
typedef long double ld;

const int MOD = 1234567891;

const int M = 15;
const int N = M*8;

struct Matrix{
	int a[N][N];
	int* operator[](int id){
		return a[id];
	}
	Matrix(){
		memset(a,0,sizeof(a));
	}
	Matrix(int){
		memset(a,0,sizeof(a));
		for (int i = 0; i < N; i++)
			a[i][i] = 1;
	}
};

Matrix operator*(Matrix& a, Matrix& b){
	Matrix res;
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
			for (int k = 0; k < N; k++)
				res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
	return res;
}

Matrix operator^( Matrix& a,ll b){
	Matrix res(1);
	Matrix temp = a;
	for (ll i = 0; i < 63; i++){
		if (b & (1LL << i))
			res = res * temp;
		temp = temp * temp;	
	}
	return res;
}

int pow(int x,int b){
	if (!b) return 1;
	if (b&1) return (pow(x, b-1) * 1LL * x) % MOD;
	int temp = pow(x,b/2);
	return (temp * 1LL * temp) % MOD;
}

int inv(int x){
	return pow(x,MOD - 2);
}

int Cnk(int n,int k){
	if (n < k || n < 0) return 0;
	ll res = 1;
	for (int i = k+1; i <= res; i++)
		res = (res * i) % MOD;
	for (int i = 1; i <= n-k; i++)
		res = (res * inv(i)) % MOD;
	return res;
}

class TheBrickTowerHardDivOne {

int id[4][4][4];
int K,C;

Matrix go;

int getmsk(int x,int y,int z,int q){
	int cnt = 1;
	int a = 0;
	int b,c,d;
	
	if (y == x) b = a;
	else b = cnt++;
	
	if (z == x)	c = a;
	else if (z == y) c = b;
	else c = cnt++;
	
	if (q == x) d = a;
	else if (q == y) d = b;
	else if (q == z) d = c;
	else d = cnt++;
	
	return id[b][c][d];
}


void addgo(int x,int y,int z,int x1,int y1,int z1,int q1){
	int a[2][2][2];
	
	a[0][0][0] = 0;
	a[0][0][1] = x;
	a[0][1][0] = y;
	a[0][1][1] = z;
	a[1][0][0] = x1;
	a[1][0][1] = y1;
	a[1][1][0] = z1;
	a[1][1][1] = q1;
	
	int cnt = 0;
	for (int i = 0; i < 2; i++)
		for (int j = 0; j < 2; j++){
			if (a[1][i][j] == a[0][i][j])
				cnt+=2;
			if (a[1][i][j] == a[1][i^1][j])
				cnt++;
			if (a[1][i][j] == a[1][i][j^1])
				cnt++;
		}
	cnt /= 2;
	
	int msk = getmsk(x1,y1,z1,q1);
	int oldmsk = getmsk(0,x,y,z);
	
	int mc = 0;
	mc = max(mc, x), mc = max(mc,y), mc = max(mc,z);
	int mc1 = mc;
	mc = max(mc, x1), mc = max(mc,y1), mc = max(mc,z1), mc = max(mc, q1);
		
	int tmp = Cnk(C - mc1,mc - mc1);
		
	for (int i = 0; i + cnt <= K; i++)
		go[oldmsk + M * i][msk + (M + cnt) * i] += tmp;
}

public:
    int find(int _C, int _K, long long H) {
    	this->K = _K;
    	this->C = _C;
    	int cnt = 0;
        for (int i = 0; i <= 1; i++)
        	for (int j = 0; j <= i+1; j++)
        		for (int k = 0; k <= max(i,j)+1; k++)
        			id[i][j][k] = cnt++;
                			         
        for (int i = 0; i <= 1; i++)
        	for (int j = 0; j <= i+1; j++){
        		int Mij = max(i,j);
        		for (int k = 0; k <= Mij+1; k++){      
        			int Mijk = max(Mij,k);  			
        			for (int i1 = 0; i1 <= Mijk+1; i1++){
        				int M4 = max(Mijk, i1);
        				for (int j1 = 0; j1 <= M4+1; j1++){
        					int M5 = max(M4, j1);
        					for (int k1 = 0; k1 <= M5+1; k1++){
        						int M6 = max(M5, k1);
        						for (int q1 = 0; q1 <= M6+1; q1++){
        							addgo(i,j,k,i1,j1,k1,q1);
        						}
        					}
        				}
        			}
        		}
        	}
        							
        Matrix res = (go ^ (H - 1));
        
        int ans = 0;
        
       
        for (int i = 0; i <= 1; i++)
        	for (int j = 0; j <= i+1; j++)
        		for (int k = 0; k <= max(i,j)+1; k++){
        			int t = Cnk(C, max(i,max(j,k))+1);
        			
        			int cl = 0;
        			cl += (i == 0) + (j == 0);
        			cl += (i == k) + (j == k);
        			
        			if (cl == 0 && t)
        				cout << i<< " "<<j<<" "<<k<<endl;
        			
        			for (int I = 0; I < N; I++){
        				if (res[id[i][j][k] + cl * M][I]) cerr << "!"<<i <<" "<<j<" "<<k << endl;
        				ans = (ans + t * 1LL * res[id[i][j][k] + cl * M][I]) % MOD;
        			}
        		}
        
        return ans % MOD;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, long long p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	TheBrickTowerHardDivOne *obj;
	int answer;
	obj = new TheBrickTowerHardDivOne();
	clock_t startTime = clock();
	answer = obj->find(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	long long p2;
	int p3;
	
	{
	// ----- test 0 -----
	p0 = 2;
	p1 = 0;
	p2 = 2ll;
	p3 = 4;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 1;
	p1 = 7;
	p2 = 19ll;
	p3 = 1;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 2;
	p1 = 3;
	p2 = 1ll;
	p3 = 14;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 4;
	p1 = 7;
	p2 = 47ll;
	p3 = 1008981254;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING




//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
