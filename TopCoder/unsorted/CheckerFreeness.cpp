#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <sstream>
#include <iterator>
#include <functional>
#include <bitset>
#include <ctime>
#define pb push_back
#define mp make_pair      
using namespace std;
 
typedef long long ll;
typedef long double ld;

struct point{
	int x,y;
	point(){}
	point(int x,int y):x(x),y(y){
	}
};


point operator-(const point& a,const point& b){
	return point(a.x - b.x,a.y - b.y);
}

ll operator*(const point& a,const point& b){
	return a.x * 1LL * b.y - a.y * 1LL * b.x;
}

int sign(ll a){
	return (a > 0) - (a < 0);
}

struct line{
	ll a,b,c;
	
	line(){};
	line(point p1,point p2){
		a = p1.y - p2.y;
		b = p2.x - p1.x;
		c = - a*p1.x - b*p1.y;
	}
	
	int side(point p){
		return sign(a*p.x + b*p.y + c);
	}	
};


struct Comparer{
	point CompPoint;
	bool operator()(const point& a,const point& b){
		return (a-CompPoint)*(b - CompPoint) > 0;
	}
	Comparer(point p):CompPoint(p){
	}
};

class CheckerFreeness {

vector<point> w;
vector<point> b;

void parce(vector<string> _x,vector<string> _y,vector<point>& p){
	string x;
	for (int i = 0; i < (int)_x.size(); i++)
		x += _x[i];
	stringstream strx(x);

	string y;
	for (int i = 0; i < (int)_y.size(); i++)
		y += _y[i];
	stringstream stry(y);
	
		
	int X,Y;
		
	while (strx >> X, stry >> Y)
		p.pb(point(X,Y));
}

ll calcall(vector<point> w,vector<point> b){
	ll ans = 0;
	for (int i = 0; i < (int)w.size(); i++)
		for (int j = i+1; j < (int)w.size(); j++){
			line l(w[i],w[j]);
			int cntp,cntm;
			cntp = cntm = 0;
			for (int k = 0; k < (int)b.size(); k++)
				if (l.side(b[k]) == 1)
					cntp++;
				else
					cntm++;
			ans += cntp * 1LL * cntm;
		}
	return ans;			
}

ll calcbad(vector<point> w,vector<point> b){
	ll ans = 0;
	
	for (int i = 0; i < (int)w.size(); i++){
		for (int j = 0; j < (int)w.size(); j++)
		if (i != j){
			vector<point> left,right;
			line l(w[i],w[j]);
			for (int k = 0; k < (int)b.size(); k++)
				if (l.side(b[k]) == 1)
					left.pb(b[k]);
				else
					right.pb(b[k]);
				
			sort(left.begin(),left.end(),Comparer(w[i]));
			sort(right.begin(),right.end(),Comparer(w[i]));
			
			int ptr = 0;
			/*{
			cerr << w[i].x <<" "<<w[i].y <<" "<<w[j].x << " "<<w[j].y << endl;
			for (int i = 0; i < (int)left.size(); i++)
				cerr<<"("<<left[i].x <<" "<<left[i].y <<") ";
			cerr << endl;
			for (int i = 0; i < (int)right.size(); i++)
				cerr<<"("<<right[i].x <<" "<<right[i].y <<") ";
			cerr << endl;
			}*/
			for (int k = 0; k < (int)left.size(); k++){
				while (ptr < (int)right.size() && (left[k] - w[i]) * (right[ptr] - w[i]) > 0){
					ptr++;
				}
				//cerr << i <<" "<<j<<" "<<ptr << endl;
				ans += ptr;
			}
		}
	}	
	
	return ans;
}

public:
    string isFree(vector <string> _x, vector <string> _y, vector <string> _x2, vector <string> _y2) {
        parce(_x,_y,w);
        parce(_x2,_y2,b);
        
        ll all = calcall(w,b) + calcall(b,w);
        ll bad = calcbad(w,b) + calcbad(b,w);
        #ifdef LOCAL
        assert((all - bad)%2 == 0);
        #endif
        return ((all == bad) ? "YES" : "NO");
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, vector <string> p2, vector <string> p3, bool hasAnswer, string p4) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p2[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p3[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	CheckerFreeness *obj;
	string answer;
	obj = new CheckerFreeness();
	clock_t startTime = clock();
	answer = obj->isFree(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p4 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	vector <string> p2;
	vector <string> p3;
	string p4;
	
	{
	// ----- test 0 -----
	string t0[] = {"1 2"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"2 1"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"1 2"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	string t3[] = {"1 2"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = "NO";
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"2","5","3"," ","1","7","3"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"180 254"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"32","5 1","42"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	string t3[] = {"462 423"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = "YES";
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"1 10000000 9999999"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"1 9999999 1"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"2 5000000 9999998"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	string t3[] = {"2 5000001 9999999"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = "YES";
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"2"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"3"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	string t3[] = {"4"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = "YES";
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"6115 9723 3794 2275 2268 2702 3657 915 7953 2743 7","716 9645 2547 9490 9365 326 6601 5215 6771 7153 72","93 5922 714 2258 4369 9524 302 8417 6620 1143"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"621 1611 7140 503 5345 7202 681 4908 2510 5908 279","6 6286 6873 6682 9197 6710 8517 1913 7784 8533 665","4 446 3561 7241 6168 2025 4739 9501 5340 6446"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"6833 131 4151 1776 1959 7210 1903 6107 598 6220 94","24 5374 6718 2919 6068 6644 5070 710 7121 1630 370","3 1051 5739 9294 8798 3371 8107 2130 6608 534"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	string t3[] = {"7496 2412 2801 3473 5810 2714 7853 9714 5470 3558 ","8143 2391 8234 7292 9311 1636 8978 1107 2262 9175 ","7259 8842 5294 7209 2317 3825 3413 820 3774 5393"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = "NO";
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"219211 1996214 1706774 3634920 909831 1774128 8503","52 2233050 2099138 3380396 1128982 3682525 1483700"," 763080 487867 8203 1791027 463556 1103323 1406861"," 6374234 760949 4340236 727393 2073832 1289052 103","8147 4448130 151066 412440 1068735 377239 2677933 ","1299598 339843 289973 3707319 555280 230418 431719"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"1638083 5698739 3105504 9726902 9745795 5049444 15","80592 3952120 6606668 7460527 7239299 8726128 4913","547 6264100 5701660 8865937 4969114 8014845 327236","1 6389154 9739755 2561669 9412417 5452337 3150506 ","5832197 1571976 8779325 3306446 948271 5133709 949","394 6919798 7525636 3568024 6833196 9237472 733313","1 9939064 9720014"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	string t2[] = {"5860334 8007503 7455523 4864927 9573526 2718360 81","12104 6684287 9921506 4840886 5415948 3451454 5320","996 9268757 9261724 8254668 2292750 8035828 233352","1 7676906 5234406 8533320 6562751 4884098 4971897 ","5569360 8519168 3100295 9351613 7733878 7579030 32","46775 7297460 8370542 7099759 5782969 2978083 3390","488 7482758 1332401 6094629 9717305 5503121 572842","1 4903563 6331656 2867455 3410007 7751527 7228221 ","4111694 5171296 6847697 4601273 7599828 5515929 94","60593 9332762 5389080 4512091 8668538 5711743 5838","534 4825079 8145628 3810005 2964724 5594550 785748","3 6283769"};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	string t3[] = {"5911694 8009943 212555 5838688 9896256 607434 5857","663 4616750 1477573 7168026 3090917 4379806 326465","7 4189076 2104028 3279691 94211 8503556 78457 4394","360 3344176 3223317 2624498 4883494 1532240 732937","1 1518674 1353567 892134 5536454 8527392 2603965 6","623264 8830827 2030444 3002706 83058 4475866 20876","25 1790695 4034441 5409379 3571098 4600050 736561 ","250475 3733256 3011439 2144994 4523046 3119883 607","582 8361403 6525451 7518329 926803 4884524 8424659"," 7088689 5762049 9532481 4914186 7314621 4339084 3","741685 3837953 3177252 612550 9688871 5872931"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = "YES";
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING





//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
