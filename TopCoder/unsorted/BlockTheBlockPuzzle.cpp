#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <iterator>
#include <functional>
#include <bitset>
#include <ctime>
#include <cassert>
#define pb push_back
#define mp make_pair      
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;
 
typedef long long ll;
typedef long double ld;


const int INF = 1e6;

class Flow {
	struct Edge {
		int c, to, next;
		Edge(int c, int to, int next) :c(c), to(to), next(next){}
	};
	
	vector<Edge> es;
	vector<int> fir;
	int n;
	
	public:
	
	Flow(int _n):es(), fir(_n, -1), n(_n){}
	
	void adde(int a, int b, int c){
//	    eprintf("%d %d %d\n", a, b, c);
		es.pb(Edge(c, b, fir[a]));
		fir[a] = (int)es.size()-1;
		es.pb(Edge(0, a, fir[b]));
		fir[b] = (int)es.size()-1;
	}
	
	vector<bool> used;
	
	int dfs(int v, int to, int cur){
//	    eprintf("!%d %d %d\n", v, to, cur);
		if (v == to) return cur;
		if (used[v]) return 0;
		used[v] = true;
		for (int i = fir[v]; i != -1; i = es[i].next){
			if (!es[i].c) continue;
			int temp = dfs(es[i].to, to, min(cur, es[i].c));
			if (temp > 0) {
				es[i].c -= temp;
			    es[i^1].c += temp;
			    return temp;
			}
		}		    
		return 0;
	}
	
	int flow(int s, int e){
	    int tot = 0;
		while (true) {
		    used = vector<bool>(n);
			int cur = dfs(s, e, INF);
			tot += cur;
			if (!cur || tot >= INF) return tot;
		}
	}
};

class BlockTheBlockPuzzle {

int conv(char c){
	if (c == 'H') return 0;
	if (c == '.') return 1;
	return INF;
}

public:
    int minimumHoles(vector <string> g) {
    	int n = (int)g.size();
    	int m = (int)g[0].size();
        Flow s(n * m * 2 + 2);
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        for (int i = 0; i < n; i++)
        	for (int j = 0; j < m; j++) {
        		int id = (i * m + j) * 2;
       			s.adde(id, id + 1, conv(g[i][j]));
        		if (g[i][j] == 'b')
        			s.adde(n * m * 2, id, INF);
        		if (g[i][j] == '$')
        			s.adde(id + 1, n * m * 2 + 1, INF);
        		for (int dir = 0; dir < 4; dir++) {
        			if (!(0 <= i + 3 * dx[dir] && i + 3 * dx[dir] < n)) continue;
        			if (!(0 <= j + 3 * dy[dir] && j + 3 * dy[dir] < m)) continue;
        			int tot = conv(g[i + dx[dir]][j + dy[dir]]) + conv(g[i + 2*dx[dir]][j + 2*dy[dir]]);
        			int nid = ((i + 3*dx[dir]) * m + (j + 3 * dy[dir])) * 2;
        			s.adde(id + 1, nid, tot);
        		}
        	}
        int res = s.flow(2*n * m, 2*n * m + 1);
        if (res >= INF) return -1;
        return res;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	BlockTheBlockPuzzle *obj;
	int answer;
	obj = new BlockTheBlockPuzzle();
	clock_t startTime = clock();
	answer = obj->minimumHoles(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	int p1;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {"b..$","....","HHHH","HHHH"};
	p1 = 2;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"............H..","...............","...............","HHH$HHH.....H..","HHHHHHH........","HHHHHHHH.......","......b..H.....","...............","...............","...H..H..H.....","...............","...............","...............","...............","..............."};
	p1 = 0;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"............H..","...............","...............","HHH$HHH........","HHHHHHH........","HHHHHHHH.......","......b..H.....","...............","...............","...H..H..H.....","...............","...............","...............","...............","..............."};
	p1 = 1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {"b..$...","...H...",".......","b..b..b","...H...",".......","b..b..b"};
	p1 = 4;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {"b..b..b","..b..b.",".......","b..$bbb",".b.....","....b..","b..b..b"};
	p1 = -1;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
